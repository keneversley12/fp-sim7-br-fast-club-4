{"ast":null,"code":"/**\n * Script loading is difficult thanks to IE. We need callbacks to fire\n * immediately following the script's execution, with no other scripts\n * running in between. If other scripts on the page are able to run\n * between our script and its callback, bad things can happen, such as\n * `jQuery.noConflict` not being called in time, resulting in plugins\n * latching onto our version of jQuery, etc.\n *\n * For IE<10 we use a relatively well-documented \"preloading\" strategy,\n * which ensures that the script is ready to execute *before* appending\n * it to the DOM. That way when it is finally appended, it is\n * executed immediately.\n *\n * References:\n * - http://www.html5rocks.com/en/tutorials/speed/script-loading/\n * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/\n * - https://github.com/jrburke/requirejs/issues/526\n * - https://connect.microsoft.com/IE/feedback/details/729164/\n *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely\n */\n(function () {\n  // Global state.\n  var pendingScripts = {};\n  var scriptCounter = 0;\n\n  /**\n   * Insert script into the DOM\n   *\n   * @param {Object} script Script DOM object\n   * @returns {void}\n   */\n  var _addScript = function (script) {\n    // Get the first script element, we're just going to use it\n    // as a reference for where to insert ours. Do NOT try to do\n    // this just once at the top and then re-use the same script\n    // as a reference later. Some weird loaders *remove* script\n    // elements after the browser has executed their contents,\n    // so the same reference might not have a parentNode later.\n    var firstScript = document.getElementsByTagName(\"script\")[0];\n\n    // Append the script to the DOM, triggering execution.\n    firstScript.parentNode.insertBefore(script, firstScript);\n  };\n\n  /**\n   * Load Script.\n   *\n   * @param {String}            src       URI of script\n   * @param {Function|Object}   callback  (Optional) Called on script load completion,\n   *                                      or options object\n   * @param {Object}            context   (Optional) Callback context (`this`)\n   * @returns {void}\n   */\n  var _lload = function (src, callback, context) {\n    /*eslint max-statements: [2, 32]*/\n    var setup;\n    if (callback && typeof callback !== \"function\") {\n      context = callback.context || context;\n      setup = callback.setup;\n      callback = callback.callback;\n    }\n    var script = document.createElement(\"script\");\n    var done = false;\n    var err;\n    var _cleanup; // _must_ be set below.\n\n    /**\n     * Final handler for error or completion.\n     *\n     * **Note**: Will only be called _once_.\n     *\n     * @returns {void}\n     */\n    var _finish = function () {\n      // Only call once.\n      if (done) {\n        return;\n      }\n      done = true;\n\n      // Internal cleanup.\n      _cleanup();\n\n      // Callback.\n      if (callback) {\n        callback.call(context, err);\n      }\n    };\n\n    /**\n     * Error handler\n     *\n     * @returns {void}\n     */\n    var _error = function () {\n      err = new Error(src || \"EMPTY\");\n      _finish();\n    };\n    if (script.readyState && !(\"async\" in script)) {\n      /*eslint-disable consistent-return*/\n\n      // This section is only for IE<10. Some other old browsers may\n      // satisfy the above condition and enter this branch, but we don't\n      // support those browsers anyway.\n\n      var id = scriptCounter++;\n      var isReady = {\n        loaded: true,\n        complete: true\n      };\n      var inserted = false;\n\n      // Clear out listeners, state.\n      _cleanup = function () {\n        script.onreadystatechange = script.onerror = null;\n        pendingScripts[id] = void 0;\n      };\n\n      // Attach the handler before setting src, otherwise we might\n      // miss events (consider that IE could fire them synchronously\n      // upon setting src, for example).\n      script.onreadystatechange = function () {\n        var firstState = script.readyState;\n\n        // Protect against any errors from state change randomness.\n        if (err) {\n          return;\n        }\n        if (!inserted && isReady[firstState]) {\n          inserted = true;\n\n          // Append to DOM.\n          _addScript(script);\n        }\n\n        // --------------------------------------------------------------------\n        //                       GLORIOUS IE8 HACKAGE!!!\n        // --------------------------------------------------------------------\n        //\n        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so\n        // we have to resort to drastic measures.\n        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02\n        //\n        // As with all things development, there's a Stack Overflow comment that\n        // asserts the following combinations of state changes in IE8 indicate a\n        // script load error. And crazily, it seems to work!\n        //\n        // http://stackoverflow.com/a/18840568/741892\n        //\n        // The `script.readyState` transitions we're interested are:\n        //\n        // * If state starts as `loaded`\n        // * Call `script.children`, which _should_ change state to `complete`\n        // * If state is now `loading`, then **we have a load error**\n        //\n        // For the reader's amusement, here is HeadJS's catalog of various\n        // `readyState` transitions in normal operation for IE:\n        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419\n        if (firstState === \"loaded\") {\n          // The act of accessing the property should change the script's\n          // `readyState`.\n          //\n          // And, oh yeah, this hack is so hacky-ish we need the following\n          // eslint disable...\n          /*eslint-disable no-unused-expressions*/\n          script.children;\n          /*eslint-enable no-unused-expressions*/\n\n          if (script.readyState === \"loading\") {\n            // State transitions indicate we've hit the load error.\n            //\n            // **Note**: We are not intending to _return_ a value, just have\n            // a shorter short-circuit code path here.\n            return _error();\n          }\n        }\n\n        // It's possible for readyState to be \"complete\" immediately\n        // after we insert (and execute) the script in the branch\n        // above. So check readyState again here and react without\n        // waiting for another onreadystatechange.\n        if (script.readyState === \"complete\") {\n          _finish();\n        }\n      };\n\n      // Onerror handler _may_ work here.\n      script.onerror = _error;\n\n      // Since we're not appending the script to the DOM yet, the\n      // reference to our script element might get garbage collected\n      // when this function ends, without onreadystatechange ever being\n      // fired. This has been witnessed to happen. Adding it to\n      // `pendingScripts` ensures this can't happen.\n      pendingScripts[id] = script;\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      // This triggers a request for the script, but its contents won't\n      // be executed until we append it to the DOM.\n      script.src = src;\n\n      // In some cases, the readyState is already \"loaded\" immediately\n      // after setting src. It's a lie! Don't append to the DOM until\n      // the onreadystatechange event says so.\n    } else {\n      // This section is for modern browsers, including IE10+.\n\n      // Clear out listeners.\n      _cleanup = function () {\n        script.onload = script.onerror = null;\n      };\n      script.onerror = _error;\n      script.onload = _finish;\n      script.async = true;\n      script.charset = \"utf-8\";\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n      script.src = src;\n\n      // Append to DOM.\n      _addScript(script);\n    }\n  };\n\n  // UMD wrapper.\n  /*global define:false*/\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    module.exports = _lload;\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], function () {\n      return _lload;\n    });\n  } else {\n    // VanillaJS\n    window._lload = _lload;\n  }\n})();","map":{"version":3,"names":["pendingScripts","scriptCounter","_addScript","script","firstScript","document","getElementsByTagName","parentNode","insertBefore","_lload","src","callback","context","setup","createElement","done","err","_cleanup","_finish","call","_error","Error","readyState","id","isReady","loaded","complete","inserted","onreadystatechange","onerror","firstState","children","onload","async","charset","exports","module","define","amd","window"],"sources":["/Users/lordsosa/Desktop/strategio-project/fp-sim7-br-fast-club/node_modules/little-loader/lib/little-loader.js"],"sourcesContent":["/**\n * Script loading is difficult thanks to IE. We need callbacks to fire\n * immediately following the script's execution, with no other scripts\n * running in between. If other scripts on the page are able to run\n * between our script and its callback, bad things can happen, such as\n * `jQuery.noConflict` not being called in time, resulting in plugins\n * latching onto our version of jQuery, etc.\n *\n * For IE<10 we use a relatively well-documented \"preloading\" strategy,\n * which ensures that the script is ready to execute *before* appending\n * it to the DOM. That way when it is finally appended, it is\n * executed immediately.\n *\n * References:\n * - http://www.html5rocks.com/en/tutorials/speed/script-loading/\n * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/\n * - https://github.com/jrburke/requirejs/issues/526\n * - https://connect.microsoft.com/IE/feedback/details/729164/\n *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely\n */\n(function () {\n\n  // Global state.\n  var pendingScripts = {};\n  var scriptCounter = 0;\n\n  /**\n   * Insert script into the DOM\n   *\n   * @param {Object} script Script DOM object\n   * @returns {void}\n   */\n  var _addScript = function (script) {\n    // Get the first script element, we're just going to use it\n    // as a reference for where to insert ours. Do NOT try to do\n    // this just once at the top and then re-use the same script\n    // as a reference later. Some weird loaders *remove* script\n    // elements after the browser has executed their contents,\n    // so the same reference might not have a parentNode later.\n    var firstScript = document.getElementsByTagName(\"script\")[0];\n\n    // Append the script to the DOM, triggering execution.\n    firstScript.parentNode.insertBefore(script, firstScript);\n  };\n\n  /**\n   * Load Script.\n   *\n   * @param {String}            src       URI of script\n   * @param {Function|Object}   callback  (Optional) Called on script load completion,\n   *                                      or options object\n   * @param {Object}            context   (Optional) Callback context (`this`)\n   * @returns {void}\n   */\n  var _lload = function (src, callback, context) {\n    /*eslint max-statements: [2, 32]*/\n    var setup;\n\n    if (callback && typeof callback !== \"function\") {\n      context = callback.context || context;\n      setup = callback.setup;\n      callback = callback.callback;\n    }\n\n    var script = document.createElement(\"script\");\n    var done = false;\n    var err;\n    var _cleanup; // _must_ be set below.\n\n    /**\n     * Final handler for error or completion.\n     *\n     * **Note**: Will only be called _once_.\n     *\n     * @returns {void}\n     */\n    var _finish = function () {\n      // Only call once.\n      if (done) { return; }\n      done = true;\n\n      // Internal cleanup.\n      _cleanup();\n\n      // Callback.\n      if (callback) {\n        callback.call(context, err);\n      }\n    };\n\n    /**\n     * Error handler\n     *\n     * @returns {void}\n     */\n    var _error = function () {\n      err = new Error(src || \"EMPTY\");\n      _finish();\n    };\n\n    if (script.readyState && !(\"async\" in script)) {\n      /*eslint-disable consistent-return*/\n\n      // This section is only for IE<10. Some other old browsers may\n      // satisfy the above condition and enter this branch, but we don't\n      // support those browsers anyway.\n\n      var id = scriptCounter++;\n      var isReady = { loaded: true, complete: true };\n      var inserted = false;\n\n      // Clear out listeners, state.\n      _cleanup = function () {\n        script.onreadystatechange = script.onerror = null;\n        pendingScripts[id] = void 0;\n      };\n\n      // Attach the handler before setting src, otherwise we might\n      // miss events (consider that IE could fire them synchronously\n      // upon setting src, for example).\n      script.onreadystatechange = function () {\n        var firstState = script.readyState;\n\n        // Protect against any errors from state change randomness.\n        if (err) { return; }\n\n        if (!inserted && isReady[firstState]) {\n          inserted = true;\n\n          // Append to DOM.\n          _addScript(script);\n        }\n\n        // --------------------------------------------------------------------\n        //                       GLORIOUS IE8 HACKAGE!!!\n        // --------------------------------------------------------------------\n        //\n        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so\n        // we have to resort to drastic measures.\n        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02\n        //\n        // As with all things development, there's a Stack Overflow comment that\n        // asserts the following combinations of state changes in IE8 indicate a\n        // script load error. And crazily, it seems to work!\n        //\n        // http://stackoverflow.com/a/18840568/741892\n        //\n        // The `script.readyState` transitions we're interested are:\n        //\n        // * If state starts as `loaded`\n        // * Call `script.children`, which _should_ change state to `complete`\n        // * If state is now `loading`, then **we have a load error**\n        //\n        // For the reader's amusement, here is HeadJS's catalog of various\n        // `readyState` transitions in normal operation for IE:\n        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419\n        if (firstState === \"loaded\") {\n          // The act of accessing the property should change the script's\n          // `readyState`.\n          //\n          // And, oh yeah, this hack is so hacky-ish we need the following\n          // eslint disable...\n          /*eslint-disable no-unused-expressions*/\n          script.children;\n          /*eslint-enable no-unused-expressions*/\n\n          if (script.readyState === \"loading\") {\n            // State transitions indicate we've hit the load error.\n            //\n            // **Note**: We are not intending to _return_ a value, just have\n            // a shorter short-circuit code path here.\n            return _error();\n          }\n        }\n\n        // It's possible for readyState to be \"complete\" immediately\n        // after we insert (and execute) the script in the branch\n        // above. So check readyState again here and react without\n        // waiting for another onreadystatechange.\n        if (script.readyState === \"complete\") {\n          _finish();\n        }\n      };\n\n      // Onerror handler _may_ work here.\n      script.onerror = _error;\n\n      // Since we're not appending the script to the DOM yet, the\n      // reference to our script element might get garbage collected\n      // when this function ends, without onreadystatechange ever being\n      // fired. This has been witnessed to happen. Adding it to\n      // `pendingScripts` ensures this can't happen.\n      pendingScripts[id] = script;\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      // This triggers a request for the script, but its contents won't\n      // be executed until we append it to the DOM.\n      script.src = src;\n\n      // In some cases, the readyState is already \"loaded\" immediately\n      // after setting src. It's a lie! Don't append to the DOM until\n      // the onreadystatechange event says so.\n\n    } else {\n      // This section is for modern browsers, including IE10+.\n\n      // Clear out listeners.\n      _cleanup = function () {\n        script.onload = script.onerror = null;\n      };\n\n      script.onerror = _error;\n      script.onload = _finish;\n      script.async = true;\n      script.charset = \"utf-8\";\n\n      // call the setup callback to mutate the script tag\n      if (setup) {\n        setup.call(context, script);\n      }\n\n      script.src = src;\n\n      // Append to DOM.\n      _addScript(script);\n    }\n  };\n\n  // UMD wrapper.\n  /*global define:false*/\n  if (typeof exports === \"object\" && typeof module === \"object\") {\n    // CommonJS\n    module.exports = _lload;\n\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], function () { return _lload; });\n\n  } else {\n    // VanillaJS\n    window._lload = _lload;\n  }\n}());\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}